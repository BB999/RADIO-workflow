name: Publish to Podcast

on:
  workflow_call:
    inputs:
      episode-number:
        required: true
        type: string
      episode-title:
        required: true
        type: string
      episode-description:
        required: true
        type: string
      audio-url:
        required: true
        type: string
      image-url:
        required: false
        type: string
      script-content:
        required: false
        type: string
      transcript:
        required: false
        type: string
    secrets:
      GH_TOKEN:
        required: true

jobs:
  update-rss:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
          ref: main
      
      - name: Get current date and generate episode title
        id: date
        run: |
          # Âü∫Êú¨„ÅÆÊó•‰ªòÊÉÖÂ†±
          echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT
          echo "rfc_date=$(date -R)" >> $GITHUB_OUTPUT
          echo "year=$(date +'%Y')" >> $GITHUB_OUTPUT
          echo "month=$(date +'%m')" >> $GITHUB_OUTPUT
          echo "day=$(date +'%d')" >> $GITHUB_OUTPUT
          echo "formatted_date=$(date +'%Y.%-m.%-d')" >> $GITHUB_OUTPUT
          
          # Êó•Êú¨ÊôÇÈñì„ÅßÊó•‰ªò„Å®ÊôÇÂàª„ÇíÂèñÂæó
          TZ='Asia/Tokyo'
          JP_DATE=$(TZ=$TZ date +'%Y.%-m.%-d')
          JP_HOUR=$(TZ=$TZ date +'%-H')
          
          # morning/afternoon„ÅÆÂà§ÂÆö
          if [ $JP_HOUR -lt 12 ]; then
            TIME_PERIOD="morning"
          else
            TIME_PERIOD="afternoon"
          fi
          
          # „Çø„Ç§„Éà„É´„Å´Êó•‰ªò„Å®ÊôÇÈñìÂ∏Ø„ÇíËøΩÂä†
          BASE_TITLE="${{ inputs.episode-title }}"
          FULL_TITLE="${BASE_TITLE} ${JP_DATE} ${TIME_PERIOD}"
          echo "episode_title=$FULL_TITLE" >> $GITHUB_OUTPUT
          echo "üìª Episode title: $FULL_TITLE"
      
      - name: Generate episode summary
        id: summary
        run: |
          # „Éá„Éï„Ç©„É´„Éà„ÅÆË¶ÅÁ¥Ñ„Çí‰ΩøÁî®
          SUMMARY="${{ inputs.episode-description }}"
          
          # 300ÊñáÂ≠ó„Å´Âà∂Èôê
          if [ ${#SUMMARY} -gt 300 ]; then
            SUMMARY="${SUMMARY:0:297}..."
          fi
          
          # ÊîπË°å„Çí„Ç®„Çπ„Ç±„Éº„Éó
          SUMMARY=$(echo "$SUMMARY" | tr '\n' ' ')
          echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
      
      - name: Analyze audio file
        id: audio-analysis
        run: |
          echo "::group::Installing ffmpeg"
          # Install ffmpeg for audio analysis
          sudo apt-get update && sudo apt-get install -y ffmpeg
          echo "::endgroup::"
          
          echo "::group::Downloading audio file"
          # Download audio file once for both duration and size analysis
          echo "üì• Starting download from: ${{ inputs.audio-url }}"
          TEMP_AUDIO=$(mktemp --suffix=.mp3)
          echo "üìÅ Temporary file: $TEMP_AUDIO"
          
          # Download with verbose logging
          echo "‚è≥ Downloading audio file..."
          HTTP_CODE=$(curl -L -s -w "%{http_code}" -o "$TEMP_AUDIO" "${{ inputs.audio-url }}")
          CURL_EXIT_CODE=$?
          
          if [ $CURL_EXIT_CODE -ne 0 ]; then
            echo "::error::Failed to download audio file (curl exit code: $CURL_EXIT_CODE)"
            echo "‚ùå URL: ${{ inputs.audio-url }}"
            rm -f "$TEMP_AUDIO"
            exit 1
          fi
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::HTTP error $HTTP_CODE when downloading audio file"
            echo "‚ùå URL: ${{ inputs.audio-url }}"
            rm -f "$TEMP_AUDIO"
            exit 1
          fi
          
          echo "‚úÖ Successfully downloaded audio file (HTTP $HTTP_CODE)"
          echo "::endgroup::"
          
          echo "::group::Analyzing file size"
          # Get file size
          AUDIO_SIZE=$(stat -c%s "$TEMP_AUDIO" 2>/dev/null || stat -f%z "$TEMP_AUDIO" 2>/dev/null)
          if [ -z "$AUDIO_SIZE" ]; then
            echo "::error::Failed to get file size using stat command"
            ls -la "$TEMP_AUDIO"
            rm -f "$TEMP_AUDIO"
            exit 1
          fi
          
          # Calculate size in different units
          SIZE_KB=$(($AUDIO_SIZE / 1024))
          SIZE_MB=$(($AUDIO_SIZE / 1024 / 1024))
          
          echo "üìä File size analysis:"
          echo "   - Bytes: $AUDIO_SIZE"
          echo "   - KB: $SIZE_KB"
          echo "   - MB: $SIZE_MB"
          
          # Check if file size is valid
          if [ "$AUDIO_SIZE" -lt 1000 ]; then
            echo "::error::Audio file is too small ($AUDIO_SIZE bytes). File may be corrupted."
            echo "‚ùå Expected at least 1KB, got $AUDIO_SIZE bytes"
            rm -f "$TEMP_AUDIO"
            exit 1
          fi
          
          echo "‚úÖ File size is valid"
          echo "::endgroup::"
          
          echo "::group::Analyzing audio duration"
          # Get actual duration with error output
          echo "‚è≥ Running ffprobe..."
          FFPROBE_OUTPUT=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "$TEMP_AUDIO" 2>&1)
          FFPROBE_EXIT_CODE=$?
          
          if [ $FFPROBE_EXIT_CODE -ne 0 ]; then
            echo "::error::ffprobe failed with exit code $FFPROBE_EXIT_CODE"
            echo "‚ùå ffprobe output: $FFPROBE_OUTPUT"
            rm -f "$TEMP_AUDIO"
            exit 1
          fi
          
          DURATION_SECONDS=$(echo "$FFPROBE_OUTPUT" | head -n 1)
          
          if [ -z "$DURATION_SECONDS" ]; then
            echo "::error::ffprobe returned empty duration"
            echo "‚ùå ffprobe output was: $FFPROBE_OUTPUT"
            rm -f "$TEMP_AUDIO"
            exit 1
          fi
          
          # Convert seconds to MM:SS format
          MINUTES=$(echo "$DURATION_SECONDS" | awk '{print int($1/60)}')
          SECONDS=$(echo "$DURATION_SECONDS" | awk '{print int($1%60)}')
          FORMATTED_DURATION=$(printf "%02d:%02d" $MINUTES $SECONDS)
          
          echo "üìä Duration analysis:"
          echo "   - Total seconds: $DURATION_SECONDS"
          echo "   - Minutes: $MINUTES"
          echo "   - Seconds: $SECONDS"
          echo "   - Formatted: $FORMATTED_DURATION"
          
          echo "‚úÖ Duration analysis complete"
          echo "::endgroup::"
          
          # Summary
          echo "::notice title=Audio Analysis Complete::File size: $SIZE_MB MB, Duration: $FORMATTED_DURATION"
          
          # Output both values
          echo "size=$AUDIO_SIZE" >> $GITHUB_OUTPUT
          echo "duration=$FORMATTED_DURATION" >> $GITHUB_OUTPUT
          
          # Cleanup
          rm -f "$TEMP_AUDIO"
          echo "üßπ Temporary file cleaned up"
      
      - name: Create episodes directory
        run: |
          mkdir -p docs/episodes
      
      - name: Generate episode HTML
        run: |
          cat > docs/episodes/episode-${{ inputs.episode-number }}.html << 'EOF'
          <!DOCTYPE html>
          <html lang="ja">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>${{ inputs.episode-title }} - Á•ûÂ®ÅÊó•Â†±„É©„Ç∏„Ç™</title>
              <meta property="og:title" content="${{ inputs.episode-title }}">
              <meta property="og:description" content="${{ steps.summary.outputs.summary }}">
              <meta property="og:image" content="${{ inputs.image-url }}">
              <meta property="og:type" content="music.radio_station">
              <style>
                  body {
                      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                      max-width: 800px;
                      margin: 0 auto;
                      padding: 2rem;
                      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                      min-height: 100vh;
                  }
                  .episode-container {
                      background: white;
                      border-radius: 15px;
                      padding: 2rem;
                      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
                  }
                  h1 { color: #667eea; }
                  .episode-meta { color: #666; margin: 1rem 0; }
                  audio { width: 100%; margin: 2rem 0; }
                  .transcript {
                      background: #f8f9fa;
                      padding: 1.5rem;
                      border-radius: 10px;
                      margin-top: 2rem;
                      white-space: pre-wrap;
                      line-height: 1.8;
                  }
                  .back-link {
                      display: inline-block;
                      margin-top: 2rem;
                      color: white;
                      text-decoration: none;
                      background: rgba(255,255,255,0.2);
                      padding: 10px 20px;
                      border-radius: 50px;
                  }
              </style>
          </head>
          <body>
              <a href="/RADIO-workflow/" class="back-link">‚Üê Êàª„Çã</a>
              <div class="episode-container">
                  <h1>${{ steps.date.outputs.episode_title }}</h1>
                  <div class="episode-meta">
                      <p>ÈÖç‰ø°Êó•: ${{ steps.date.outputs.date }}</p>
                      <p>„Ç®„Éî„ÇΩ„Éº„Éâ #${{ inputs.episode-number }}</p>
                  </div>
                  ${{ inputs.image-url && format('<img src="{0}" alt="Episode thumbnail" style="width: 100%; border-radius: 10px; margin: 1rem 0;">', inputs.image-url) || '' }}
                  <audio controls>
                      <source src="${{ inputs.audio-url }}" type="audio/mpeg">
                      „Åä‰Ωø„ÅÑ„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØÈü≥Â£∞„Çø„Ç∞„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ
                  </audio>
                  <div class="description">
                      <h2>üìù Ê¶ÇË¶Å</h2>
                      <p>${{ steps.summary.outputs.summary }}</p>
                  </div>
              </div>
          </body>
          </html>
          EOF
      
      - name: Update RSS feed
        run: |
          # „Ç∑„Çß„É´„Çπ„ÇØ„É™„Éó„Éà„ÅßRSS„Éï„Ç£„Éº„Éâ„ÇíÊõ¥Êñ∞
          RSS_FILE="docs/podcast.xml"
          EPISODE_GUID="https://bb999.github.io/RADIO-workflow/episodes/episode-${{ inputs.episode-number }}.html"
          
          # Êó¢Â≠ò„ÅÆ„Ç®„Éî„ÇΩ„Éº„Éâ„ÉÅ„Çß„ÉÉ„ÇØÔºàÈáçË§áÈò≤Ê≠¢Ôºâ
          if grep -q "<guid[^>]*>$EPISODE_GUID</guid>" "$RSS_FILE"; then
            echo "‚ö†Ô∏è Episode #${{ inputs.episode-number }} already exists in RSS feed. Skipping duplicate."
            exit 0
          fi
          
          # Êñ∞„Åó„ÅÑ„Ç®„Éî„ÇΩ„Éº„Éâ„ÅÆXMLÁîüÊàêÔºà„Éí„Ç¢„Éâ„Ç≠„É•„É°„É≥„Éà‰ΩøÁî®Ôºâ
          cat > episode_temp.xml << EPISODE_EOF
              <item>
                  <title>${{ steps.date.outputs.episode_title }}</title>
                  <description><![CDATA[${{ steps.summary.outputs.summary }}]]></description>
                  <link>$EPISODE_GUID</link>
                  <guid isPermaLink="true">$EPISODE_GUID</guid>
                  <pubDate>${{ steps.date.outputs.rfc_date }}</pubDate>
                  <enclosure url="${{ inputs.audio-url }}" length="${{ steps.audio-analysis.outputs.size }}" type="audio/mpeg"/>
                  <itunes:author>Kamui Radio AI</itunes:author>
                  <itunes:summary><![CDATA[${{ steps.summary.outputs.summary }}]]></itunes:summary>
                  <itunes:duration>${{ steps.audio-analysis.outputs.duration }}</itunes:duration>
                  <itunes:explicit>false</itunes:explicit>
                  <itunes:episode>${{ inputs.episode-number }}</itunes:episode>
                  <itunes:season>1</itunes:season>
          EPISODE_EOF
          
          # ÁîªÂÉèURL„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØËøΩÂä†
          if [ -n "${{ inputs.image-url }}" ]; then
            echo "        <itunes:image href=\"${{ inputs.image-url }}\"/>" >> episode_temp.xml
          fi
          
          echo "    </item>" >> episode_temp.xml
          
          # ‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê
          TEMP_FILE=$(mktemp)
          
          # lastBuildDate„ÇíÊõ¥Êñ∞„Åó„ÄÅÊñ∞„Åó„ÅÑ„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíËøΩÂä†
          awk -v new_date="${{ steps.date.outputs.rfc_date }}" '
            /<lastBuildDate>/ { 
              print "        <lastBuildDate>" new_date "</lastBuildDate>"
              next
            }
            /<\/channel>/ {
              # Êñ∞„Åó„ÅÑ„Ç®„Éî„ÇΩ„Éº„Éâ„ÇíÊåøÂÖ•
              while ((getline line < "episode_temp.xml") > 0) {
                print line
              }
              close("episode_temp.xml")
              print $0
              next
            }
            { print }
          ' "$RSS_FILE" > "$TEMP_FILE"
          
          # Êõ¥Êñ∞„Åï„Çå„ÅüRSS„Çí‰øùÂ≠ò
          mv "$TEMP_FILE" "$RSS_FILE"
          rm -f episode_temp.xml
          echo "‚úÖ RSS feed updated successfully with episode #${{ inputs.episode-number }}"
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add docs/
          git commit -m "üéôÔ∏è Add Episode #${{ inputs.episode-number }}: ${{ inputs.episode-title }}"
          git push origin main
      
      - name: Trigger GitHub Pages build
        run: |
          echo "üöÄ GitHub Pages will automatically rebuild with the new episode"
          echo "üì° RSS feed is now updated at: https://bb999.github.io/RADIO-workflow/podcast.xml"
          echo "üéß Episode page: https://bb999.github.io/RADIO-workflow/episodes/episode-${{ inputs.episode-number }}.html"